'use strict';import{AssertionError,AttributeError,BaseException,DeprecationWarning,Exception,IndexError,IterableError,KeyError,NotImplementedError,RuntimeWarning,StopIteration,UserWarning,ValueError,Warning,__JsIterator__,__PyIterator__,__Terminal__,__add__,__and__,__call__,__class__,__envir__,__eq__,__floordiv__,__ge__,__get__,__getcm__,__getitem__,__getslice__,__getsm__,__gt__,__i__,__iadd__,__iand__,__idiv__,__ijsmod__,__ilshift__,__imatmul__,__imod__,__imul__,__in__,__init__,__ior__,__ipow__,
__irshift__,__isub__,__ixor__,__jsUsePyNext__,__jsmod__,__k__,__kwargtrans__,__le__,__lshift__,__lt__,__matmul__,__mergefields__,__mergekwargtrans__,__mod__,__mul__,__ne__,__neg__,__nest__,__or__,__pow__,__pragma__,__proxy__,__pyUseJsNext__,__rshift__,__setitem__,__setproperty__,__setslice__,__sort__,__specialattrib__,__sub__,__super__,__t__,__terminal__,__truediv__,__withblock__,__xor__,abs,all,any,assert,bool,bytearray,bytes,callable,chr,copy,deepcopy,delattr,dict,dir,divmod,enumerate,filter,float,
getattr,hasattr,input,int,isinstance,issubclass,len,list,map,max,min,object,ord,pow,print,property,py_TypeError,py_iter,py_metatype,py_next,py_reversed,py_typeof,range,repr,round,set,setattr,sorted,str,sum,tuple,zip}from"./org.transcrypt.__runtime__.js";import{Pot}from"./card_utils.games.poker.pot.js";import{Action}from"./card_utils.games.poker.action.js";import{Dict,List}from"./typing.js";var __name__="__main__";export var PokerGameState=__class__("PokerGameState",[object],{__module__:__name__,py_name:"abstract_poker",
showdown_street:0,get __init__(){return __get__(this,function(self,num_players,deck,starting_stacks,hands,boards,ante,blinds,stacks,action,street,actions,action_dicts,last_actions,pot_balances){if(typeof boards=="undefined"||boards!=null&&boards.hasOwnProperty("__kwargtrans__"))var boards=null;if(typeof ante=="undefined"||ante!=null&&ante.hasOwnProperty("__kwargtrans__"))var ante=0;if(typeof blinds=="undefined"||blinds!=null&&blinds.hasOwnProperty("__kwargtrans__"))var blinds=null;if(typeof stacks==
"undefined"||stacks!=null&&stacks.hasOwnProperty("__kwargtrans__"))var stacks=null;if(typeof action=="undefined"||action!=null&&action.hasOwnProperty("__kwargtrans__"))var action=null;if(typeof street=="undefined"||street!=null&&street.hasOwnProperty("__kwargtrans__"))var street=0;if(typeof actions=="undefined"||actions!=null&&actions.hasOwnProperty("__kwargtrans__"))var actions=null;if(typeof action_dicts=="undefined"||action_dicts!=null&&action_dicts.hasOwnProperty("__kwargtrans__"))var action_dicts=
null;if(typeof last_actions=="undefined"||last_actions!=null&&last_actions.hasOwnProperty("__kwargtrans__"))var last_actions=null;if(typeof pot_balances=="undefined"||pot_balances!=null&&pot_balances.hasOwnProperty("__kwargtrans__"))var pot_balances=null;if(num_players<2){var __except0__=ValueError("Fundamentally, poker is a game of more than 1 player\n{} was instantiated with {} players".format(self.__class__.__name__,num_players));__except0__.__cause__=null;throw __except0__;}self.num_players=num_players;
self.deck=deck;if(len(hands)!=num_players){var __except0__=ValueError("PokerGameState.__init__: (hands)must have exactly one hand per player".format());__except0__.__cause__=null;throw __except0__;}self.hands=hands;if(len(starting_stacks)!=num_players){var __except0__=ValueError("PokerGameState.__init__: must have exactly one starting stack per player".format());__except0__.__cause__=null;throw __except0__;}self.starting_stacks=starting_stacks;self.stacks=stacks||function(){var __accu0__=[];for(var s of starting_stacks)__accu0__.append(s);
return __accu0__}();var boards=boards||[[]];if(!__in__(len(boards),new set([1,num_players]))){var __except0__=ValueError("PokerGameState.__init__: (boards)must have exactly one board, or a board for every player".format());__except0__.__cause__=null;throw __except0__;}self.boards=boards;var blinds=blinds||[];if(!(ante||any(blinds))){var __except0__=ValueError("There must be either an ante or blinds to play poker".format());__except0__.__cause__=null;throw __except0__;}self.ante=ante;self.blinds=blinds;
self.last_actions=last_actions||dict({});if(actions&&action_dicts){var __except0__=ValueError("can only provide either action or action_dicts to initialise poker game state, not both");__except0__.__cause__=null;throw __except0__;}else if(action_dicts)var actions=function(){var __accu0__=[];for(var ad of action_dicts)__accu0__.append(Action(__kwargtrans__(ad)));return __accu0__}();self.actions=actions||[];self.pot=Pot(self.num_players,pot_balances);self.street=street;if(action===null){self.extract_antes_and_blinds();
var action=self.get_starting_action()}self.action=action;self.payouts=dict({});self.is_complete=false})},get from_action_dicts(){return __getcm__(this,function(cls,num_players,deck,hands,starting_stacks,boards,ante,blinds,action_dicts){if(typeof boards=="undefined"||boards!=null&&boards.hasOwnProperty("__kwargtrans__"))var boards=null;if(typeof ante=="undefined"||ante!=null&&ante.hasOwnProperty("__kwargtrans__"))var ante=0;if(typeof blinds=="undefined"||blinds!=null&&blinds.hasOwnProperty("__kwargtrans__"))var blinds=
null;if(typeof action_dicts=="undefined"||action_dicts!=null&&action_dicts.hasOwnProperty("__kwargtrans__"))var action_dicts=null;var game_state=cls(__kwargtrans__({num_players:num_players,deck:deck,hands:hands,starting_stacks:starting_stacks,boards:boards,ante:ante,blinds:blinds}));game_state.reset_state_from_action_dicts(action_dicts||[]);return game_state})},get get_starting_action(){return __get__(this,function(self){var __except0__=NotImplementedError("NotImplementedError in {}: You must override get_starting_action in subclasses of PokerGameState".format(self.__class__.__name__));
__except0__.__cause__=null;throw __except0__;})},get order_hands(){return __get__(this,function(self,players){var __except0__=NotImplementedError("All PokerGameState objects must implement order_hands to decide who wins at showdown".format());__except0__.__cause__=null;throw __except0__;})},get is_all_in(){return __get__(this,function(self,player){return self.stacks[player]==0})},get put_money_in_pot(){return __get__(this,function(self,player,amount){if(amount>self.stacks[player]){var __except0__=
Exception("player {} only has {} chips, but trying to put {} in pot".format(player,self.stacks[player],amount));__except0__.__cause__=null;throw __except0__;}self.stacks[player]-=amount;self.pot.put_money_in(player,amount)})},get extract_antes(){return __get__(this,function(self){for(var player=0;player<self.num_players;player++){var amount=min(self.stacks[player],self.ante);self.put_money_in_pot(player,amount)}})},get extract_blinds(){return __get__(this,function(self){for(var [player,blind]of enumerate(self.blinds)){var amount=
min(self.stacks[player],blind);self.put_money_in_pot(player,amount)}})},get extract_antes_and_blinds(){return __get__(this,function(self){self.extract_antes();self.extract_blinds()})},get reset_state_from_action_dicts(){return __get__(this,function(self,action_dicts){self.stacks=function(){var __accu0__=[];for(var s of self.starting_stacks)__accu0__.append(s);return __accu0__}();self.pot=Pot(self.num_players);self.last_actions=dict({});self.payouts=dict({});self.extract_antes_and_blinds();self.street=
0;self.action=self.get_starting_action();for(var action_dict of action_dicts)self.act(__kwargtrans__(action_dict))})},get act(){return __get__(this,function(self){var args=tuple([].slice.apply(arguments).slice(1));self.append_action(...args,__kwargtrans__(kwargs));self.advance_action()})},get append_action(){return __get__(this,function(self){var args=tuple([].slice.apply(arguments).slice(1));if(self.is_complete){var __except0__=Exception("cannot append_action after the hand is_complete".format());
__except0__.__cause__=null;throw __except0__;}var action_obj=self.build_action(...args,__kwargtrans__(kwargs));self.validate_action(action_obj);self.actions.append(action_obj);self.update_state_with_action(action_obj)})},get build_action(){return __get__(this,function(self,player,action,amount){if(typeof amount=="undefined"||amount!=null&&amount.hasOwnProperty("__kwargtrans__"))var amount=null;if(amount===null)if(action==Action.action_call)var amount=self.amount_to_call;else if(__in__(action,Action.zeros))var amount=
0;else{var __except0__=ValueError("Amount cannot be None for action type {}".format(action));__except0__.__cause__=null;throw __except0__;}return Action(__kwargtrans__(__mergekwargtrans__({player:player,action:action,amount:amount},state)))})},get validate_action(){return __get__(this,function(self,action){if(action.player!=self.action){var __except0__=Exception("The calculated action is on {}, but the next Action object comes from {}".format(self.action,action.player));__except0__.__cause__=null;
throw __except0__;}if(!__in__(action.action,self.valid_actions)){var __except0__=ValueError("it is {} to call, so {} is invalid".format(self.amount_to_call,action.action));__except0__.__cause__=null;throw __except0__;}if(self.stacks[action.player]<action.amount){var __except0__=Exception("Player {} only has {} in stack, less than the desired wager of {}".format(action.player,self.stacks[action.player],action.amount));__except0__.__cause__=null;throw __except0__;}if(__in__(action.action,Action.aggressions))if(action.amount<
self.min_bet){var __except0__=ValueError("Invalid {} size: amount {} is less than the minimum of {}".format(action.action,action.amount,self.min_bet));__except0__.__cause__=null;throw __except0__;}if(__in__(action.action,Action.aggressions))if(action.amount>self.max_bet){var __except0__=ValueError("Invalid {} size: amount {} is greater than the limit of {}".format(action.action,action.amount,self.max_bet));__except0__.__cause__=null;throw __except0__;}})},get _get_valid_actions(){return __get__(this,
function(self){if(self.amount_to_call==0)return Action.zero_to_call;else return Action.nonzero_to_call})},get update_state_with_action(){return __get__(this,function(self,action){if(__in__(action.action,Action.wagers))self.put_money_in_pot(__kwargtrans__({player:action.player,amount:action.amount}));self.last_actions[action.player]=action.action})},get advance_action(){return __get__(this,function(self){var is_action_closed=self.is_action_closed();if(!is_action_closed)self.move_action();else while(is_action_closed&&
self.street<self.showdown_street){self.move_street();var is_action_closed=self.is_action_closed()}if(self.street>=self.showdown_street){self.payouts=self.get_payouts();self.is_complete=true}})},get get_payouts(){return __get__(this,function(self){var players_at_showdown=function(){var __accu0__=[];for(var player=0;player<self.num_players;player++)if(self.last_actions.py_get(player)!=Action.action_fold)__accu0__.append(player);return __accu0__}();var winners=len(players_at_showdown)>1?self.order_hands(players_at_showdown):
[players_at_showdown];var payouts=self.pot.settle_showdown(winners);return payouts})},get cannot_act(){return __get__(this,function(self,player){return bool(self.is_all_in(player)||self.last_actions.py_get(player)==Action.action_fold)})},get mod_n(){return __get__(this,function(self,player){return __mod__(player,self.num_players)})},get get_next_action(){return __get__(this,function(self){return self.mod_n(self.action+1)})},get increment_action(){return __get__(this,function(self){self.action=self.get_next_action()})},
get move_action(){return __get__(this,function(self){self.increment_action();while(self.cannot_act(self.action))self.increment_action()})},get move_street(){return __get__(this,function(self){self.street++;self.last_actions=function(){var __accu0__=[];for(var [player,action]of self.last_actions.py_items())if(action==Action.action_fold)__accu0__.append([player,Action.action_fold]);return dict(__accu0__)}();try{self.action=self.get_starting_action()}catch(__except0__){if(isinstance(__except0__,StopIteration)){if(!self.is_action_closed()){var __except1__=
Exception("The action is not closed, but we could not find the player who starts the action, so there is a bug. Fix me");__except1__.__cause__=null;throw __except1__;}self.action=null}else throw __except0__;}})},get is_action_closed(){return __get__(this,function(self){var folders=0;var checkers=0;var all_in_last_street=0;var not_yet_acted=0;var not_all_in_set=set();for(var player=0;player<self.num_players;player++){var last_action=self.last_actions.py_get(player);var is_all_in=self.is_all_in(player);
if(last_action!=Action.action_fold&&!is_all_in)not_all_in_set.add(player);if(last_action===null&&is_all_in)all_in_last_street++;else if(last_action===null)not_yet_acted++;else if(last_action==Action.action_fold)folders++;else if(last_action==Action.action_check)checkers++}var not_all_in_balances=new set([function(){var __accu0__=[];for(var p of not_all_in_set)__accu0__.append(self.pot.balances[p]);return set(__accu0__)}(),max(self.pot.balances.py_values())]);if(len(not_all_in_balances)>1)return false;
if(folders==self.num_players-1)return true;if(len(not_all_in_balances)==1)if(folders+all_in_last_street==self.num_players-1)return true;if(folders+checkers+all_in_last_street==self.num_players)return true;return not_yet_acted==0})},get _get_amount_to_call(){return __get__(this,function(self){var max_owed_to_pot=max(self.pot.balances.py_values())-self.pot.balances[self.action];var stack_size=self.stacks[self.action];return min(stack_size,max_owed_to_pot)})},get _get_min_bet(){return __get__(this,function(self){var biggest_blind=
max([self.ante,self.blinds]);var sorted_pot_balances=sorted(self.pot.balances.py_values(),__kwargtrans__({reverse:true}));var last_raise_delta=sorted_pot_balances[0]-sorted_pot_balances[1];var min_bet=max(biggest_blind,last_raise_delta+self.amount_to_call);var stack_size=self.stacks[self.action];return min(min_bet,stack_size)})},get _get_max_bet(){return __get__(this,function(self){return self.stacks[self.action]})},get player_pnl(){return __get__(this,function(self,player){return self.payouts.py_get(player,
0)+self.stacks[player]-self.starting_stacks[player]})},get _get_pnl(){return __get__(this,function(self){return function(){var __accu0__=[];for(var player=0;player<self.num_players;player++)__accu0__.append([player,self.player_pnl(player)]);return dict(__accu0__)}()})}});Object.defineProperty(PokerGameState,"pnl",property.call(PokerGameState,PokerGameState._get_pnl));Object.defineProperty(PokerGameState,"max_bet",property.call(PokerGameState,PokerGameState._get_max_bet));Object.defineProperty(PokerGameState,
"min_bet",property.call(PokerGameState,PokerGameState._get_min_bet));Object.defineProperty(PokerGameState,"amount_to_call",property.call(PokerGameState,PokerGameState._get_amount_to_call));Object.defineProperty(PokerGameState,"valid_actions",property.call(PokerGameState,PokerGameState._get_valid_actions));

//# sourceMappingURL=game_state.map