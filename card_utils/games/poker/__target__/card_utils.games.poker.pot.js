'use strict';import{AssertionError,AttributeError,BaseException,DeprecationWarning,Exception,IndexError,IterableError,KeyError,NotImplementedError,RuntimeWarning,StopIteration,UserWarning,ValueError,Warning,__JsIterator__,__PyIterator__,__Terminal__,__add__,__and__,__call__,__class__,__envir__,__eq__,__floordiv__,__ge__,__get__,__getcm__,__getitem__,__getslice__,__getsm__,__gt__,__i__,__iadd__,__iand__,__idiv__,__ijsmod__,__ilshift__,__imatmul__,__imod__,__imul__,__in__,__init__,__ior__,__ipow__,
__irshift__,__isub__,__ixor__,__jsUsePyNext__,__jsmod__,__k__,__kwargtrans__,__le__,__lshift__,__lt__,__matmul__,__mergefields__,__mergekwargtrans__,__mod__,__mul__,__ne__,__neg__,__nest__,__or__,__pow__,__pragma__,__proxy__,__pyUseJsNext__,__rshift__,__setitem__,__setproperty__,__setslice__,__sort__,__specialattrib__,__sub__,__super__,__t__,__terminal__,__truediv__,__withblock__,__xor__,abs,all,any,assert,bool,bytearray,bytes,callable,chr,copy,deepcopy,delattr,dict,dir,divmod,enumerate,filter,float,
getattr,hasattr,input,int,isinstance,issubclass,len,list,map,max,min,object,ord,pow,print,property,py_TypeError,py_iter,py_metatype,py_next,py_reversed,py_typeof,range,repr,round,set,setattr,sorted,str,sum,tuple,zip}from"./org.transcrypt.__runtime__.js";import{inverse_cumulative_sum}from"./card_utils.util.js";var __name__="card_utils.games.poker.pot";export var Pot=__class__("Pot",[object],{__module__:__name__,get __init__(){return __get__(this,function(self,num_players,balances){if(typeof balances==
"undefined"||balances!=null&&balances.hasOwnProperty("__kwargtrans__"))var balances=null;self.num_players=num_players;self.balances=balances||function(){var __accu0__=[];for(var p=0;p<num_players;p++)__accu0__.append([p,0]);return dict(__accu0__)}()})},get put_money_in(){return __get__(this,function(self,player,amount){self.balances[player]+=amount})},get settle_showdown(){return __get__(this,function(self,winning_players){var payouts=function(){var __accu0__=[];for(var p=0;p<self.num_players;p++)__accu0__.append([p,
0]);return dict(__accu0__)}();for(var winner_tier of winning_players){var incremental_amounts=self.get_incremental_amounts(winner_tier);for(var inc_amt of incremental_amounts){var players_chopping=function(){var __accu0__=[];for(var winner of winner_tier)if(self.balances[winner]>=inc_amt)__accu0__.append(winner);return __accu0__}();var money_per_winner=sum(function(){var __accu0__=[];for(var money_left of self.balances.py_values())__accu0__.append(min(money_left,inc_amt)/len(players_chopping));return py_iter(__accu0__)}());
for(var winner of players_chopping)payouts[winner]+=money_per_winner;for(var p=0;p<self.num_players;p++)self.balances[p]=max(0,self.balances[p]-inc_amt)}if(self.total_money==0)return payouts}var __except0__=Exception("Reached end of loop in Pot.settle_showdown, but there is still {} in the pot!".format(self.total_money));__except0__.__cause__=null;throw __except0__;})},get _get_total_money(){return __get__(this,function(self){return sum(self.balances.py_values())})},get get_incremental_amounts(){return __get__(this,
function(self,players){var cumulative_amounts=sorted(function(){var __accu0__=[];for(var p of players)__accu0__.append(self.balances[p]);return py_iter(__accu0__)}());return inverse_cumulative_sum(cumulative_amounts)})}});Object.defineProperty(Pot,"total_money",property.call(Pot,Pot._get_total_money));

//# sourceMappingURL=card_utils.games.poker.pot.map